<canvas id="ctx" width="500" height="500" style="border: 1px solid #000"></canvas>

<script type="text/javascript">
	var ctx  = document.getElementById('ctx').getContext('2d')

	//1. Modify Settings =
	ctx.font = '30px Arial';  //; font used
	// ctx.fillStyle = 'red';		// color of the text and forms
	// ctx.globalAlpha = 0.5;		// transparency 0: invisible ; 1: visible
	
	// 2. Draw something
	// ctx.fillText('Hello',50,50); //write text ... ctx.fillText('text', x, y)
	// ctx.fillRect(50,50,100,100); // draw rectangle .. ctx.fillRect(startX, startY, width, height)
	// ctx.clearRect(75,75,100,100); // clear canvas ... ctx.fillRect(startX, startY, width, height)

	const HEIGHT = 500;
	const WIDTH = 500;
	const DISTANCE_COLLIDING= 30;
	let timeWhenGameStarted = Date.now();

	var frameCount = 0;
	var score = 0;

	// player
	let player = {
		x: 50,
		spdX: 40,
		y: 30, 
		spdY: 5,
		width: 20,
		height: 20,
		name:'P',
		color: "green",
		hp: 20,
		atkSpd : 1,
		attackCounter : 0,
		pressingUp: false,
		pressingDown: false,
		pressingLeft: false,
		presssingRight: false,
		aimAngle: 0,
	}

	let enemyList = {};
	let upgradeList = {};
	let bulletList = {};


	//FUNCTION DECLARATION
	getDistanceBetweenEntity = function (entity1, entity2) { // return distance (number)
		let vx=entity1.x -entity2.x;
		let vy = entity1.y - entity2.y;
		return Math.sqrt(vx*vx + vy*vy);
	}

	// testCollisionEntity = function (entity1, entity2){ // return if colliding (true/false)
	// 	let distance = getDistanceBetweenEntity(entity1,entity2);
	// 	return distance < DISTANCE_COLLIDING; // return true neu distance nho hon 10
	// }
	testCollisionEntity = function (entity1, entity2){ // return if colliding (true/false)
		let rect1 = {
			x: entity1.x - entity1.width / 2,
			y:  entity1.y - entity1.height / 2,
			width: entity1.width,
			height : entity1.height
		}

		let rect2 = {
			x: entity2.x - entity2.width / 2,
			y: entity2.y - entity2.height / 2,
			width: entity2.width,
			height : entity2.height
		}
		return testCollisionRectRect(rect1,rect2);
	}

	testCollisionRectRect =  function (rect1, rect2){
		return rect1.x <= rect2.x + rect2.width
			&& rect2.x <= rect1.x + rect1.width
			&& rect1.y <= rect2.y + rect2.width
			&& rect2.y <= rect1.y + rect1.width
	}

	updateEntity = function (something){
		updateEntityPosition(something);
		drawEntity(something);
	}

	updateEntityPosition = function(something){
		something.x += something.spdX;
		something.y += something.spdY;

		if(something.x < 0 || something.x > WIDTH) {
			something.spdX = -something.spdX;
		}

		if(something.y < 0 || something.y > HEIGHT) {
			something.spdY = -something.spdY
		}
	}

	drawEntity = function (something){
		ctx.save();
		ctx.fillStyle = something.color;
		ctx.fillRect(something.x-something.width / 2,something.y - something.height / 2,something.width ,something.height);
		ctx.restore();
	}

	enemy = function (id, x, y, spdX, spdY,width,height) {
		let enemy = {
			x: x,
			spdX: spdX,
			y:y, 
			spdY: spdY,
			width : width,
			height: height,
			name: "E" ,
			color: "red",
			id: id,
			aimAngle: 0
		}

		enemyList[id] = enemy;
	}

	randomlyGenerateEnemy = function(){
        //Math.random() returns a number between 0 and 1
        var x = Math.random()*WIDTH;
        var y = Math.random()*HEIGHT;
        var height = 10 + Math.random()*30;     //between 10 and 40
        var width = 10 + Math.random()*30;
        var id = Math.random();
        var spdX = 5 + Math.random() * 5;
        var spdY = 5 + Math.random() * 5;
        enemy(id,x,y,spdX,spdY,width,height);  
	}

	upgrade = function (id, x, y, spdX, spdY,width,height,category, color) {
			let upgrade = {
				x: x,
				spdX: spdX,
				y:y, 
				spdY: spdY,
				width : width,
				height: height,
				name: "U" ,
				color: color,
				category: category,
				id: id
			}

			upgradeList[id] = upgrade;
		}

	randomlyGenerateUpgrade = function(){
        //Math.random() returns a number between 0 and 1
        var x = Math.random()*WIDTH;
        var y = Math.random()*HEIGHT;
        var height = 10 ;     //between 10 and 40
        var width = 10 ;
        var id = Math.random();
        var spdX = 0;
        var spdY = 0;
        if (Math.random() < 0.5) {
        	var category = 'score';
        	var color = 'orange';	
        }else{
			var category = 'atkSpd';
        	var color = 'purple';	
        }
        upgrade(id,x,y,spdX,spdY,width,height,category,color);  
	}

	Bullet = function (id,x,y,spdX,spdY,width,height){
        var asd = {
            x:x,
            spdX:spdX,
            y:y,
            spdY:spdY,
            name:'E',
            id:id,
            width:width,
            height:height,
            color:'black',
            timer: 0,
        };
        bulletList[id] = asd;
	}
	 
	randomlyGenerateBullet = function(actor,overwriteAngle){
        //Math.random() returns a number between 0 and 1
        var x = actor.x;
        var y = actor.y;
        var height = 10;
        var width = 10;
        var id = Math.random();
       
        var angle = actor.aimAngle;
        if(overwriteAngle !== undefined){
        	angle = overwriteAngle;
        }
        var spdX = Math.cos(angle/180*Math.PI)*5;
        var spdY = Math.sin(angle/180*Math.PI)*5;
        Bullet(id,x,y,spdX,spdY,width,height);
	}

	document.onmousemove = function (mouse){
		var mouseX = mouse.clientX - document.getElementById('ctx').getBoundingClientRect().left;
		var mouseY = mouse.clientY - document.getElementById('ctx').getBoundingClientRect().top;

		mouseX -= player.x;
		mouseY -= player.y;

		player.aimAngle = Math.atan2(mouseY,mouseX) / Math.PI * 180;
	}

	document.onclick = function(mouse){ // left click
		if(player.attackCounter > 25) {
			randomlyGenerateBullet(player);
			player.attackCounter = 0;
		}
	};

	document.oncontextmenu = function(mouse){ // right click
		
		
		if(player.attackCounter > 100) {
			for(var angle = 0; angle < 360; angle++){
				randomlyGenerateBullet(player,angle);
			}
			player.attackCounter = 0;
		}else if(player.attackCounter > 75) {
			randomlyGenerateBullet(player,player.aimAngle -5);
			randomlyGenerateBullet(player);
			randomlyGenerateBullet(player,player.aimAngle +5);
			player.attackCounter = 0;
		}

		mouse.preventDefault();
	};

	document.onkeydown = function(event){
        if(event.keyCode === 68)        //d
                player.pressingRight = true;
        else if(event.keyCode === 83)   //s
                player.pressingDown = true;
        else if(event.keyCode === 65) //a
                player.pressingLeft = true;
        else if(event.keyCode === 87) // w
                player.pressingUp = true;
	}
	 
	document.onkeyup = function(event){
        if(event.keyCode === 68)        //d
                player.pressingRight = false;
        else if(event.keyCode === 83)   //s
                player.pressingDown = false;
        else if(event.keyCode === 65) //a
                player.pressingLeft = false;
        else if(event.keyCode === 87) // w
                player.pressingUp = false;
	}

	updatePlayerPosition = function(){
        if(player.pressingRight)
            player.x += 10;
        if(player.pressingLeft)
            player.x -= 10;
        if(player.pressingDown)
            player.y += 10;
        if(player.pressingUp)
            player.y -= 10;
       
        //ispositionvalid
        if(player.x < player.width/2)
            player.x = player.width/2;
        if(player.x > WIDTH-player.width/2)
            player.x = WIDTH - player.width/2;
        if(player.y < player.height/2)
            player.y = player.height/2;
        if(player.y > HEIGHT - player.height/2)
            player.y = HEIGHT - player.height/2;
	}

	update = function (){
		ctx.clearRect(0,0,WIDTH,HEIGHT); // xoa het noi dung trong canvas truoc khi ve lai
		frameCount++;
		score++;
		if(frameCount % 100 === 0)
			randomlyGenerateEnemy();

		if(frameCount % 75 === 0)
			randomlyGenerateUpgrade();

		player.attackCounter += player.atkSpd;

 		for(let key in bulletList){
            updateEntity(bulletList[key]);
            bulletList[key].timer++;

            if(bulletList[key].timer % 75 === 0){
            	delete bulletList[key];
            	continue;
            }

            for(let enemyIndex in enemyList) {
				var colliding = testCollisionEntity(bulletList[key],enemyList[enemyIndex]);
				if(colliding){
					delete bulletList[key];
					delete enemyList[enemyIndex];
					break;
				}
            }
        }

		for(var upgradeIndex in upgradeList){ 
			updateEntity(upgradeList[upgradeIndex]);
			var isColliding = testCollisionEntity(player,upgradeList[upgradeIndex]);
            if(isColliding){
            	if(upgradeList[upgradeIndex].category === 'score'){
            		score += 1000;
            	}

            	if(upgradeList[upgradeIndex].category === 'atkSpd'){
					player.atkSpd += 1;
            	}
                
                delete upgradeList[upgradeIndex];
            }
		}

		for(var enemyIndex in enemyList){
			// console.log(key);
			updateEntity(enemyList[enemyIndex]);
			var colliding = testCollisionEntity(player,enemyList[enemyIndex]);
			if(colliding){
				player.hp -= 1;
				
			}
		}

		if(player.hp <= 0) {
			let timeSurvived = Date.now() - timeWhenGameStarted;
			console.log(`you lost! You servived for ${timeSurvived} ms!`);
			startNewGame();
		}

		updatePlayerPosition(player);
		drawEntity(player);
		ctx.fillText(`${player.hp} hp `,0,30);
		ctx.fillText(`Score: ${score} `,300,30);
	}

	startNewGame = function () {
		player.hp = 20;
		timeWhenGameStarted = Date.now();
		frameCount = 0;
		score = 0;
		enemyList = {};
		upgradeList = {};
		bulletList = {};
		randomlyGenerateEnemy();
		randomlyGenerateEnemy();
		randomlyGenerateEnemy();
	}

	// start game
	startNewGame();

	setInterval(update, 40);
</script>